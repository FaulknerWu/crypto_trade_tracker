# Repository Guidelines

## Core Application Principles

- Project Goal: This is a self-service application for manually tracking and analyzing cryptocurrency contract trades.
- Key Constraint: The application is for a `manual data entry only` workflow. Users add, edit, and delete their trade records by hand.
- Out of Scope: There is `NO` functionality for connecting to exchange APIs to fetch trade data or execute orders. Do not implement or suggest any features related to API integration, data synchronization, or automated trading. The entire data lifecycle is managed manually by the user.

## Project Structure & Module Organization

- `lib/main.dart` hosts the app entry point; expand features by splitting reusable services, models, and widgets into subdirectories under `lib/`.
- Platform directories (`android/`, `ios/`, `linux/`, `macos/`, `windows/`, `web/`) are generated by Flutter; edit only for platform-specific configuration.
- Create `assets/` for images/fonts and register paths in `pubspec.yaml` under `flutter.assets`.
- Add tests under `test/` mirroring the `lib/` tree (e.g., `lib/trades/trade_service.dart` → `test/trades/trade_service_test.dart`).
- Generated output lives in `build/`; never commit it—use `flutter clean` if artifacts misbehave.
- Lint settings live in `analysis_options.yaml`; keep custom rules documented in the same file.

## Build, Test, and Development Commands

- `flutter pub get` installs dependencies after touching `pubspec.yaml`.
- `flutter run -d chrome` launches the app in a web shell for rapid UI checks; omit `-d` to target a default connected device.
- `flutter analyze` enforces `flutter_lints`; resolve warnings before pushing.
- `flutter test` executes unit and widget tests in `test/`; add `--coverage` when verifying reporting.
- `flutter build apk --release` produces an installable Android artifact; pair with `flutter build ios --release` when prepping for QA sign-off.

## Coding Style & Naming Conventions

- Use the Dart formatter (`dart format lib test`) to keep the default two-space indentation and line widths enforced.
- Favor descriptive `UpperCamelCase` for classes/widgets, `lowerCamelCase` for members, and `snake_case.dart` filenames.
- Extract stateful logic out of UI widgets into services/providers to keep `main.dart` lean.
- Leverage `const` constructors and `final` fields where possible to satisfy performance-focused lints.
- Avoid "hacky" or un-idiomatic solutions, even for temporary feature testing. Strive for clean, readable, and maintainable code at all stages. Do not commit commented-out code blocks or temporary workarounds.

## Testing Guidelines

- Write tests with `package:flutter_test`; name files `*_test.dart` and group related cases with `group()` blocks.
- Exercise asynchronous trade calculations by awaiting pumps and using fake timers where appropriate.
- Target meaningful coverage, especially around trade analytics and any future API clients; log uncovered areas in the PR description.
- Use golden tests for complex widgets when UI regressions are likely; store assets under `test/goldens/`.
- When developing UI for feature testing or validation, prioritize functionality over aesthetics. The UI should be simple and usable, but there is no need to spend time on elaborate styling or visual polish for these test-focused interfaces.